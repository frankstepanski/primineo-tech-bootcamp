## Movie Reviewer Database App - Part 4

![Pagination](images/pagination.png)

![Now Playing](images/now-playing.png)

![IMDB](images/IMDB-api-now-playing.png)


## Authentication 

Most applications allow users to register and log in using the credentials they set. The custom credentials prove they are who they say they are.

Authentication is a crucial feature for any application that allows users to create, update, or delete data. Most apps these days would not be complete without authentication because it's what allows users to have an identity on your website or app.

Authentication provides password protection to hide content from unauthorized users. It lets you serve content specifically to a user, as well as customize their settings and experience.

Each time a request is sent to the server, it would need to be authenticated so that the application can ensure that the request is from a valid user and identify the user. The easiest way to do this is by sending the username and password with each and every request.

Theoretically, one could create some kind of session and store this information in a cookie. But sessions are hard to maintain when the application grows with a large number of users and also in cases where there is one than more backend server. So there needs to be a better way.

### Basic Authentication 

The solution is to use `Basic Auth`, which requires sending the credentials with every request, but as a header.

An example:

<strong>Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l</strong>

The Basic Authentication scheme is part of the overall authentication framework provided by HTTP (see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication">this page</a> on MDN web docs for more information).

When the client wants to authenticate itself with a server (for example, log in a user), it can do so by including an Authorization request header with the user credentials. Basic Auth transmits the credentials as user ID/password pairs, which are encoded using an encoding scheme called `base64`.

### JWT (JSON Web Token)

The basic auth approach is fine for a small application with only a few end points (server). But generally, sending the password in each of your requests is not recommended and will make many users uncomfortable. Also, browsers might do things you don’t expect (like caching). 

So, what if you send the username and password only once and get a token with a limited lifespan. You could then just send the token in an encrypted form and the server can make sure that this token is valid. Even if someone picks up the token, there isn’t much they can do as it will expire soon.

That’s exactly what `JWT` does. What’s more, you can even pass some meta information about the user as well.

JSON Web Tokens (JWT) are tokens generated by the server upon user authentication on a web application, and then sent to the client (usually a browser).

To ensure integrity, information contained in the token is signed by a private key, owned by the server. When the server gets the token back from the client, it just has to compare the signature sent by the client with the one it will generate with its private key. If the signatures are identical, the token is then valid.

#### A JWT token is made of the following elements:

 - A "Header" section, containing the algorithm used for the signature, as well as the type of token ("JWT" in our case). The whole thing is encoded in Base64.
 - A "Payload" section, containing the token data, like the user name, date of token generation or expiry date. All of that is written in JSON and also encoded in Base64.
- A "Signature" section, that is the result of Header and Payload, concatenated and then encrypted with the private key.

An example:

Here is an example of a JWT token :

```JS
"Header" section :
{
  "alg": “HS256”,
  "typ": “JWT”
}

"Payload" section :
{
  "iat": 1480929282,
  "exp": 1480932868,
  "name": "Username"
}
```

#### Storing JWT on the Client

<strong>Browser memory (React state).</strong> This will keep it secure from `XSS` (Cross-Site Scripting) but will be lost anytime the user refreshes their browser or re-opens their browser. 

<strong>Local storage or session storage of the browser.</strong>  If the token is stored that way, then it will have to be included in every request sent to the server. The token will be natively protected against`CSRF attacks` considering that the token is unpredictable and cannot be retrieved by an attacke. But the token must be made available to the JavaScript application, it will be exposed in case of `XSS` vulnerabilities and might be stolen.

<strong>Good old fashioned cookies.</strong> When stored in the browser's cookies, it is possible to set the "HttpOnly" flag (and "Secure"), to get protected against token theft in case of XSS attacks.

> Since we are only focused on the front-end, we cannot properly authenticate a user. We will just simulate this method by creating a `token` after a user logs in and storing in a React state variable.

## Environment variables (.env)

An environment variable is a variable whose value is set outside the program, typically through functionality built into the operating system. An environment variable is made up of a name/value pair.

During application initialization, these are loaded into `process.env` and accessed by suffixing the name of the environment variable in your code.

```JS
const API_KEY = process.env.REACT_APP_API_KEY;
```

At runtime, the reference to the environment variable name is replaced with its current value. The primary use case for environment variables is to limit the need to modify and re-release an application due to changes in configuration data.

What to store in environment variables?

 - Execution mode (e.g., production, development, staging, etc.)
 - API URLs
 - Group mail addresses, such as those for marketing, support, sales, etc.
 - Public and private authentication keys (only secure in server applications)

The last item `public and private authentication keys` is where you would store your API key ONLY if it is stored in a back-end server application that you control.  

![env file](images/env-process.png)

> Since we have no back-end server, using an environment variable (.env) is fine for development, just not production.

But remember, anything stored in an .env is <strong>NOT</strong> secure. The values taken from the .env file will be put in the JS code and will be in the source of the bundle file that is parsed and available in the browser.

![bundle file](images/bundle.png)

## Bundle file(s)

Using Create-React-APP which uses Webpack as its file "bundler" merge all the source files into one file called the `bundle file`. 

Bundling is great, but as your app grows, your bundle will grow too. Especially if you are including large third-party libraries. You need to keep an eye on the code you are including in your bundle so that you don’t accidentally make it so large that your app takes a long time to load.

A good site to check the size the resulting bundle file for a package is <a href="https://bundlephobia.com/">bundlephobia</a>.

### Performance Costs

Like any file referenced and used on a website, the bundle file  first needs to be downloaded from a server. Then it need to be parsed, compiled, and then executed. 
 
This is a CPU-intensive operation that blocks the main thread making the page unresponsive for that time.  A user cannot interact with the page during that phase even though the content might be displayed and has seemingly finished loading. 

Also be away that performance is not consistent across devices. There is a wide range of devices available on the market with different CPU and memory specs, so it’s no surprise that the difference in JavaScript execution time between the high-end devices and average devices is huge.

### Code Splitting

To avoid winding up with a large bundle, it's good to get ahead of the problem and start "splittin" your bundle. Code-Splitting is a feature supported by bundlers like Webpack which can create multiple bundles that can be dynamically loaded at runtime.

Code-splitting your app can help you "lazy-load" just the things that are currently needed by the user, which can dramatically improve the performance of your app.

With code-splitting, our goal is to defer the loading, parsing, and execution of JavaScript code which is not needed for the current page or state.

Code splitting is available out-of-the-box for Create React App and other frameworks that use Webpack.

## References
 
- [JWT](https://jwt.io/)
- [Understanding Bundles](https://www.youtube.com/watch?v=MK62LTOt60g)
- [Bundlephobia](https://bundlephobia.com/)
- [Implementing Lazy Loading](https://www.youtube.com/watch?v=nks5rQEZsQg)
- [Understanding Form Validation](https://cxl.com/blog/form-validation/)
- [React Hook Form - Package for Handling Forms](https://react-hook-form.com/)
- [Formik - Package for Forms](https://formik.org/docs/overview)
- [React Form Validation - Custom Hook](https://www.youtube.com/watch?v=KGFG-yQD7Dw)